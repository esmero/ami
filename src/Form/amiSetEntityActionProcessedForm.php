<?php
namespace Drupal\ami\Form;

use Drupal\ami\AmiUtilityService;
use Drupal\ami\Entity\amiSetEntity;
use Drupal\Component\Datetime\TimeInterface;
use Drupal\Core\Entity\ContentEntityConfirmFormBase;
use Drupal\Core\Entity\EntityRepositoryInterface;
use Drupal\Core\Entity\EntityStorageException;
use Drupal\Core\Entity\EntityTypeBundleInfoInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\views_bulk_operations\Service\ViewsBulkOperationsActionManager;
use Drupal\views_bulk_operations\Service\ViewsBulkOperationsActionProcessorInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * Form controller for the MetadataDisplayEntity entity action form.
 *
 * @ingroup ami
 */
class amiSetEntityActionProcessedForm extends ContentEntityConfirmFormBase {

  /**
   * @var \Drupal\ami\AmiUtilityService
   */
  protected $AmiUtilityService;

  /**
   * @var ViewsBulkOperationsActionManager
   */
  protected ViewsBulkOperationsActionManager $actionManager;

  /**
   * @var ViewsBulkOperationsActionProcessorInterface
   */
  protected ViewsBulkOperationsActionProcessorInterface $actionProcessor;

  /**
   * Constructs a ContentEntityForm object.
   *
   * @param EntityRepositoryInterface $entity_repository
   *   The entity repository service.
   * @param EntityTypeBundleInfoInterface|null $entity_type_bundle_info
   *   The entity type bundle service.
   * @param TimeInterface|null $time
   *   The time service.
   * @param AmiUtilityService $ami_utility
   * @param ViewsBulkOperationsActionManager $actionManager
   * @param ViewsBulkOperationsActionProcessorInterface $actionProcessor
   */
  public function __construct(EntityRepositoryInterface $entity_repository, EntityTypeBundleInfoInterface $entity_type_bundle_info = NULL, TimeInterface $time = NULL, AmiUtilityService $ami_utility, ViewsBulkOperationsActionManager $actionManager, ViewsBulkOperationsActionProcessorInterface $actionProcessor) {

    parent::__construct($entity_repository,$entity_type_bundle_info, $time);
    $this->AmiUtilityService = $ami_utility;
    /** @var ViewsBulkOperationsActionManager $actionManager */
    $this->actionManager = $actionManager;
    /** @var ViewsBulkOperationsActionProcessorInterface $actionProcessor */
    $this->actionProcessor = $actionProcessor;
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container) {
    return new static(
      $container->get('entity.repository'),
      $container->get('entity_type.bundle.info'),
      $container->get('datetime.time'),
      $container->get('ami.utility'),
      $container->get('plugin.manager.views_bulk_operations_action'),
      $container->get('views_bulk_operations.processor')
    );
  }



  public function getQuestion() {
    return $this->t('Are you sure you want to execute action on ADOs generated by %name?', ['%name' => $this->entity->label()]);
  }

  /**
   * {@inheritdoc}
   */
  public function getCancelUrl() {
    return new Url('entity.ami_set_entity.action_process_form',['ami_set_entity' => $this->entity->id()]);
  }


  /**
   * {@inheritdoc}
   */
  public function submitForm(array &$form, FormStateInterface $form_state) {
    $csv_file_reference = $this->entity->get('source_data')->getValue();
    if (isset($csv_file_reference[0]['target_id'])) {
      $file = $this->entityTypeManager->getStorage('file')->load($csv_file_reference[0]['target_id']);
    }
    $action_config = [];
    $pluginid = $form_state->getValue('ami_select_action') ?? NULL;
    if (!empty($pluginid)) {
      $action = $this->actionManager->createInstance($pluginid, []);
      if (\method_exists($action, 'buildConfigurationForm')) {
        $action->submitConfigurationForm($form, $form_state);
      }
      $action_config = $action->getConfiguration();
    }
    else {
      $form_state->setErrorByName('ami_select_action', $this->t('You need to select an Action'));
      $form_state->setRebuild(TRUE);
      return;
    }

    // Fetch Zip file if any
    $zip_file = NULL;
    $zip_file_reference = $this->entity->get('zip_file')->getValue();
    if (isset($zip_file_reference[0]['target_id'])) {
      /** @var \Drupal\file\Entity\File $zip_file */
      $zip_file = $this->entityTypeManager->getStorage('file')->load(
        $zip_file_reference[0]['target_id']
      );
    }
    $data = new \stdClass();
    foreach($this->entity->get('set') as $item) {
      /* @var \Drupal\strawberryfield\Plugin\Field\FieldType\StrawberryFieldItem $item */
      $data = $item->provideDecoded(FALSE);
    }
    // We only run this in background
    if ($file && $data!== new \stdClass()) {
        $data_csv = clone $data;
/*
        $data->info = [
          'csv_file' => The CSV File that will (or we hope so if well formed) generate multiple ADO Queue items
       'csv_file_name' => Only present if this is called not from the root
       'set_id' => The Set id
       'uid' => The User ID that processed the Set
       'set_url' => A direct URL to the set.
        'action' => The action to run
       'action_config' => An array of additional configs/settings the particular action takes.
        'attempt' => The number of attempts to process. We always start with a 1
       'zip_file' => Zip File/File Entity
       'queue_name' => because well ... we use Hydroponics too
       'time_submitted' => Timestamp on when the queue was send. All Entries will share the same. We will use this value + set_id to generate a temporary key store to be used as batch context,
       'batch_size' =>  the number of ADOs to process via a batch action. Some actions like detele can/should handle multiple UUIDs at the same time in a single Queue item
     ];
*/
        // Overrides the original OP
        $SetURL = $this->entity->toUrl('canonical', ['absolute' => TRUE])
          ->toString();

        $run_timestamp = $this->time->getCurrentTime();
        $data_csv->pluginconfig->op = "action";
        $data_csv->info = [
          'zip_file' => $zip_file,
          'csv_file' => $file,
          'set_id' => $this->entity->id(),
          'uid' => $this->currentUser()->id(),
          'action' => $pluginid,
          'action_config' => $action_config ?? [],
          'set_url' => $SetURL,
          'attempt' => 1,
          'queue_name' => 'ami_action_ado',
          'time_submitted' => $run_timestamp,
          'batch_size' => 25
        ];
        \Drupal::queue('ami_csv_ado')
          ->createItem($data_csv);
        $form_state->setRedirectUrl($this->getCancelUrl());
        $this->messenger()->addStatus(
          $this->t('Your ADOs have been enqueued for Action Processing')
        );
      }
     else {
      $this->messenger()->addError(
        $this->t('So Sorry. Ami Set @label has incorrect Metadata and/or has its CSV file missing. We need it to know which ADOs where generated via this Set. Please correct or manually delete your ADOs.',
          [
            '@label' => $this->entity->label(),
          ]
        )
      );
    }
  }


  /**
   * {@inheritdoc}
   */
  public function buildForm(array $form, FormStateInterface $form_state) {
    $form['#prefix'] = '<div id="action-ajax-container">';
    $form['#suffix'] = '</div>';
    $data = new \stdClass();
    foreach ($this->entity->get('set') as $item) {
      /** @var \Drupal\strawberryfield\Plugin\Field\FieldType\StrawberryFieldItem $item */
      $data = $item->provideDecoded(FALSE);
    }
    if ($data !== new \stdClass()) {
      $actions = [];
      $form['process_enqueued'] = [
        '#type' => 'fieldset',
        '#title' => $this->t('Execute Action on Referenced ADOs via this Set'),
        '#description' => $this->t('Confirming will trigger a Batch Action processing for already ingested ADOs referenced by this AMI set you have permission to act on.'),
      ];
      foreach ($this->actionManager->getDefinitions() as $id => $definition) {
        if (empty($definition['type']) || \in_array($definition['type'], ['node'], TRUE)) {
         $actions[$id] = $definition;
        }
      }
      $ajax = [
        'callback' => [get_class($this), 'ajaxCallback'],
        'wrapper' => 'action-ajax-container',
      ];
      $action_options = [];
      foreach ($actions as $id => $definition) {
        $action_options[$id] = $definition['label'] ?? $id;
      }
      $form['ami_select_action'] = [
        '#type' => 'select',
        '#title' => $this->t('Execute Action on Ingested ADOs via this Set'),
        '#description' => $this->t('Confirming will trigger a Batch Action processing for already ingested ADOs you have permission to act on.'),
        "#empty_option" =>t('- Select One -'),
        '#options' => $action_options,
        '#ajax' => $ajax ,
        '#required' => TRUE,
      ];



      $pluginid = $form_state->getValue('ami_select_action') ?? NULL;
      if (!empty($pluginid))  {
        $action = $this->actionManager->createInstance($pluginid, []);

       /* if (\method_exists($action, 'setContext')) {
          $action->setContext($form_data);
        }
       */
        if (\method_exists($action, 'buildConfigurationForm')) {
          $elements = $action->buildConfigurationForm([], $form_state);
          $form = $form + $elements;
        }
      }
    }
    return $form + parent::buildForm($form, $form_state);
  }


  public static function batchAction($batch_data_uuid, &$context) {
    // Deleting nodes.
    $storage_handler = \Drupal::entityTypeManager()->getStorage('node');
    $entities = $storage_handler->loadByProperties(['uuid' => $batch_data_uuid]);
    $batch_size=sizeof($batch_data_uuid);
    $batch_number=sizeof($context['results'])+1;
    try {
      //$storage_handler->delete($entities);
      // Display data while running batch.

      $context['message'] = sprintf("processing Action %s on ADOs per batch. Batch #%s"
        , $batch_size, $batch_number);
      $context['results'][] = sizeof($batch_data_uuid);
    }
    catch (EntityStorageException $e) {
      $context['message'] = sprintf("Exception while processing Action %s on ADOs per batch. Batch #%s"
        , $batch_size, $batch_number);
      $context['results'][] = 0;
    }

  }

  // What to do after batch ran. Display success or error message.
  public static function batchFinished($success, $results, $operations) {
    if ($success) {
      $message = count($results) . ' batches processed.';
    }
    else {
      $message = 'Finished with an error.';
    }

    $messenger = \Drupal::messenger();
    if (isset($message)) {
      $messenger->addMessage($message);
    }
  }

  /**
   * Ajax callback.
   *
   * @param array $form
   *   An associative array containing the structure of the form.
   * @param \Drupal\Core\Form\FormStateInterface $form_state
   *   The current state of the form.
   *
   * @return array
   *   An partial Form.
   */
  public static function ajaxCallback(array $form, FormStateInterface $form_state) {
    $form_state->setRebuild();
    return $form;
  }
}

